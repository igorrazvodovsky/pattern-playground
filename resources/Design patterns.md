Christopher Alexander’s design patterns

# Design principles
- Design from the whole to the parts: Always consider how a decision fits into the larger living structure.
- Make patterns combinable: Patterns must connect, overlap, and reinforce one another.
- Prioritise human experience: A design is successful if people thrive in it, not just if it is efficient or elegant.
- Enable organic growth: Leave room for adaptation and change; don’t lock systems into rigid forms.

# From solutions to patterns of relationships
Good design isn’t a fixed form but a recurring relationship between context, problem, and solution.
Design implication: Don’t design features in isolation. Look at the pattern of forces shaping use.

# From top-down planning to generative systems
Alexander rejected master plans that impose rigid order. Instead, he argued for structures that can grow organically, pattern by pattern.
Design implication: Design systems that evolve and adapt with real use rather than freezing them in advance.

# From objects to living structure
Patterns are not about the object itself but about the life it fosters. A building, interface, or service is “good” if it makes people feel more alive.
Design implication: Judge designs by the quality of life they create, not just efficiency or aesthetics.

# Pattern
A description of a problem that occurs repeatedly, and the core of a solution that can be applied in many contexts.
Application: Document design decisions as patterns (context → problem → solution), not just guidelines.

# Pattern language
Patterns connect together in sequences, where the solution of one creates the context for others.
Application: Think in chains of decisions, not isolated components.

# Integration

- With design systems: Adds depth — instead of just components and rules, you get generative patterns that can guide system evolution.
- With service design: Helps map recurring interaction/service situations and design re-usable resolutions.
- With AI: Patterns provide a way to stabilise unpredictable systems by capturing repeatable, human-meaningful solutions.

# Practical methods
- Pattern spotting: Observe user behaviour or existing solutions and identify recurring structures — draft them as patterns.
- Pattern librarying: Build a shared repository of design patterns (problem → solution → context) that teams can draw from.
- Pattern sequencing: Map out how patterns connect in a flow (e.g., Onboarding → Progress visibility → Error recovery).
- Quality reflection: Ask users or team members whether a design feels “alive” or “dead.”
- Generative prototyping: Prototype by chaining patterns together, not just designing isolated screens/components.

# Questions
- What forces are at play in this situation, and what balance between them does this design achieve?
- Have I described this solution as a reusable pattern that others could recognise and apply?
- How does this pattern connect to larger or smaller ones in the system?
- Does this design allow organic adaptation over time, or does it freeze a rigid form?
